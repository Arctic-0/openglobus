precision highp float;


varying vec3 vTransformedNormal;
varying vec4 vPosition;
varying vec2 vTextureCoord;

	
//uniform vec4 uColor;
uniform sampler2D uSampler;
uniform sampler2D uNormalsMap;
 
#define MAX_POINT_LIGHTS 1

uniform int pointLightsQuantity;
uniform vec3 pointLightsPositions[MAX_POINT_LIGHTS];
uniform vec3 pointLightsParamsv[MAX_POINT_LIGHTS * 3];
uniform float pointLightsParamsf[MAX_POINT_LIGHTS];

varying mat3 v_NMatrix;

void main(void) {

    vec3 lightWeighting;
	vec3 lightDirection;
	vec3 normal;
	vec3 eyeDirection;
	vec3 reflectionDirection;
	float specularLightWeighting;
	float diffuseLightWeighting;

	//i=0
        lightDirection = normalize(pointLightsPositions[0] - vPosition.xyz);
	//float distance = length(dir);
	//float attenuation = 1.0/(1.0+0.1*distance+0.01*distance*distance);    	
	vec4 normalColor = texture2D( uNormalsMap, vTextureCoord.st/*vec2(vTextureCoord.s, 1.0 - vTextureCoord.t)*/  );	
	vec4 nc = (normalColor - 0.5) * 2.0;
	normal = normalize(v_NMatrix*normalize(nc.xyz));
        eyeDirection = normalize(-vPosition.xyz);
        reflectionDirection = reflect(-lightDirection, normal);	
	specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), pointLightsParamsf[0]);
        diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
        lightWeighting = pointLightsParamsv[0] + pointLightsParamsv[1] * diffuseLightWeighting + pointLightsParamsv[2] * specularLightWeighting;


	vec4 tColor = vec4(1.0);//texture2D( uSampler, vTextureCoord.st );
        
        gl_FragColor = vec4(tColor.rgb * lightWeighting, 1.0);
}