attribute vec3 prev;
attribute vec3 current;
attribute vec3 next;
attribute vec2 order;

//uniform mat4 projview;
uniform mat4 proj;
uniform mat4 view;
uniform vec2 viewport;
uniform float thickness;
    
vec2 project(vec4 p){
    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
}

const float C = 0.1;
const float far = 149.6e+9;
float logc = 2.0 / log( C * far + 1.0 );

const float NEAR = -1.0;

varying vec3 vPos;

void main(){

    vPos = current;

    vec4 vCurrent = view * vec4(current, 1.0);
   	vec4 vPrev = view * vec4(prev, 1.0);
	vec4 vNext = view * vec4(next, 1.0);

	//Clip near plane
	if(vCurrent.z > NEAR) {
	    if(vPrev.z < NEAR){
	        vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
	    }else if(vNext.z < NEAR){
			vPrev = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);
		}
	} else if( vPrev.z > NEAR){
        vPrev = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
	}
	
    vec4 dCurrent = proj * vCurrent;
    vec2 sCurrent = project(dCurrent);
    
	vec2 dirNext = project(proj * vNext) - sCurrent;
	vec2 sNormalNext = normalize(vec2(-dirNext.y, dirNext.x));

	vec2 dirPrev = normalize(project(proj * vPrev) - sCurrent);
	vec2 sNormalPrev = normalize(vec2(-dirPrev.y, dirPrev.x));

	vec2 dir = sNormalNext - sNormalPrev;
	float sinA = dirPrev.x * dir.y - dirPrev.y * dir.x;

	if( abs(sinA) < 0.2 ) {
		if(order.x == 1.0){
		    dir = sNormalPrev;
		} else {
		    dir = sNormalNext;   
		}
	} else {
		dir *= order.x / sinA;
	}
	
    gl_Position = vec4((2.0 * (sCurrent + dir * thickness * order.y) / viewport - 1.0) * dCurrent.w, dCurrent.z, dCurrent.w);
	gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;
}
