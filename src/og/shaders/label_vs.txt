attribute vec2 a_vertices;
attribute vec4 a_texCoord;
attribute vec3 a_positions;
attribute vec3 a_offset;
attribute float a_size;
attribute float a_rotation;
attribute vec4 a_rgba;
attribute vec3 a_alignedAxis;
attribute float a_fontIndex;
attribute vec2 a_bufferAA;

varying vec2 v_texCoords;
varying vec4 v_rgba;
varying float v_fontIndex;
varying vec3 v_bufferAA;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform vec3 uCamPos;
//0 - planetRadius^2, 1 - tan(fov), 2 - screen ratio
uniform vec2 uFloatParams;
uniform float uZ;
uniform vec3 uScaleByDistance;
uniform float uOpacity;

const vec3 ZERO3 = vec3(0.0);

const float C = 0.1;
const float far = 149.6e+9;
float logc = 2.0 / log( C * far + 1.0 );

void main() {

    if(a_texCoord.z == -1.0 || a_bufferAA.x == 1.0){
	    gl_Position = vec4(0.0);
		return;
	}

	v_fontIndex = a_fontIndex;

    v_texCoords = a_texCoord.xy;

    vec3 look = a_positions - uCamPos;
	float lookDist = length(look);

    v_rgba = a_rgba;	
	v_rgba.a *= uOpacity * step(lookDist, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(a_positions,a_positions) - uFloatParams[0]));
    
	vec3 right, up;
	if(a_alignedAxis == ZERO3){
    	up = vec3( uMVMatrix[0][1], uMVMatrix[1][1], uMVMatrix[2][1] );
	    right = vec3( uMVMatrix[0][0], uMVMatrix[1][0], uMVMatrix[2][0] );
	}else{
	    up = normalize(a_alignedAxis);
    	right = normalize(cross(look,up));
    	look = cross(up,right);
	}

	v_bufferAA = vec3(a_bufferAA, 8.0 * a_bufferAA.y / a_size);

	float dist = dot(uCamPos - a_positions, vec3(uMVMatrix[0][2], uMVMatrix[1][2], uMVMatrix[2][2]));
    float focalSize = 2.0 * dist * uFloatParams[1];    
    vec2 offset = a_offset.xy * focalSize;
    float scale = a_size * focalSize * (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));
    float cosRot = cos(a_rotation);
    float sinRot = sin(a_rotation);
    vec3 rr = (right * cosRot - up * sinRot) * (scale * (a_vertices.x + a_texCoord.z + a_texCoord.w) + offset.x) + (right * sinRot + up * cosRot) * (scale * a_vertices.y + offset.y) + a_positions;

    gl_Position = uPMatrix * uMVMatrix * vec4(rr, 1);
    gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;
	gl_Position.z += a_offset.z + uZ;
}