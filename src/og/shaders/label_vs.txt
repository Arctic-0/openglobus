attribute vec3 a_vertices;
attribute vec3 a_texCoord;
attribute vec3 a_positions;
attribute vec3 a_offset;
attribute float a_size;
attribute float a_rotation;
attribute float a_opacity;
attribute vec3 a_alignedAxis;
attribute float a_fontIndex;

varying vec2 v_texCoords;
varying float v_opacity;
varying float v_fontIndex;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform vec3 uCamPos;
uniform float uViewAngle;
uniform float uXRatio;

const vec3 ZERO3 = vec3(0.0);

void main() {
	
	v_fontIndex = a_fontIndex;

    v_texCoords = a_texCoord.xy;
    v_opacity = a_opacity;

    vec3 look = a_positions - uCamPos;
    
	vec3 right, up;
	if(a_alignedAxis == ZERO3){
    	up = vec3( uMVMatrix[0][1], uMVMatrix[1][1], uMVMatrix[2][1] );
	    right = vec3( uMVMatrix[0][0], uMVMatrix[1][0], uMVMatrix[2][0] );
	}else{
	    up = normalize(a_alignedAxis);
    	right = normalize(cross(look,up));
    	look = cross(up,right);
	}

   	//vec3 up = vec3( uMVMatrix[0][1], uMVMatrix[1][1], uMVMatrix[2][1] );
   	//vec3 right = vec3( uMVMatrix[0][0], uMVMatrix[1][0], uMVMatrix[2][0] );
	//float a = float(a_alignedAxis!=vec3(0.0));
    //up = normalize(mix(up, a_alignedAxis, a));
    //right = normalize(mix(right, cross(look,up), a));
  	//look = cross(up,right);

    float focalSize = 2.0 * length(a_positions - uCamPos) * uViewAngle * uXRatio;
    vec2 offset = a_offset.xy * focalSize;
    float scale = a_size * focalSize;
    float cosRot = cos(a_rotation);
    float sinRot = sin(a_rotation);
    vec3 rr = (right * cosRot - up * sinRot) * (scale * (a_vertices.x + a_texCoord.z) + offset.x) + (right * sinRot + up * cosRot) * (scale * a_vertices.y + offset.y) + normalize(look) * a_vertices.z + a_positions;

    gl_Position = uPMatrix * uMVMatrix * vec4(rr, 1);
	gl_Position.z += a_offset.z;
}