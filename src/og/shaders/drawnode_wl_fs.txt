#extension GL_EXT_draw_buffers : require

precision highp float;

#define MAX_POINT_LIGHTS 1
#define MAX_OVERLAYS 5
#define MAX_OVERLAYS_PLUS_ONE 6

uniform vec3 diffuseMaterial[MAX_OVERLAYS_PLUS_ONE];
uniform vec3 ambientMaterial[MAX_OVERLAYS_PLUS_ONE];
uniform vec4 specularMaterial[MAX_OVERLAYS_PLUS_ONE];

uniform sampler2D uNormalMap;
uniform vec4 lightsPositions[MAX_POINT_LIGHTS];
uniform mat3 normalMatrix;
uniform sampler2D nightTexture;
uniform sampler2D specularTexture;

uniform vec4 tileOffsetArr[MAX_OVERLAYS];
uniform vec4 visibleExtentOffsetArr[MAX_OVERLAYS];
uniform vec4 transparentColorArr[MAX_OVERLAYS];
uniform vec3 pickingColorArr[MAX_OVERLAYS];

uniform sampler2D defaultTexture;
uniform sampler2D samplerArr[MAX_OVERLAYS];
uniform int samplerCount;

varying vec4 vTextureCoord;
varying float range;
varying vec2 vGlobalTextureCoord;
varying vec4 v_vertex;
varying float v_height;

// return 1 if v inside the box, return 0 otherwise
float insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {
    vec2 s = step(bottomLeft, v) - step(topRight, v);
    return s.x * s.y;   
}

highp vec3 encode24(highp float f) {
    float F = abs(f); 
    float s = step( 0.0, -f );
    float e = floor( log2(F) ); 
    float m = exp2(- e) * F;
    e = floor( log2(F) + 127.0 ) + floor( log2(m) );
    return vec3(
		( 128.0 * s + floor( e * exp2(-1.0) ) ) / 255.0,
		( 128.0 * mod( e, 2.0 ) + mod( floor( m * 128.0 ), 128.0 ) ) / 255.0,  
		floor( mod( floor( m * exp2( 23.0 - 8.0) ), exp2(8.0) ) ) / 255.0);
}

const vec2 BOTTOMLEFT = vec2(0.0);
const vec2 TOPRIGHT = vec2(1.0);
const vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);

void main(void) {

	vec3 range24 = encode24(range);
	float overGround = 1.0 - step(0.1, v_height);
    vec3 normal = normalize(normalMatrix * ((texture2D(uNormalMap, vTextureCoord.zw).rgb - 0.5) * 2.0));
    vec3 lightDirection = normalize(lightsPositions[0].xyz - v_vertex.xyz * lightsPositions[0].w);
    vec3 eyeDirection = normalize(-v_vertex.xyz);
    vec3 reflectionDirection = reflect(-lightDirection, normal);    
    vec4 nightImageColor = texture2D( nightTexture, vGlobalTextureCoord.st );
    float shininess = texture2D( specularTexture, vGlobalTextureCoord.st ).r * 255.0;
	float reflection = max( dot(reflectionDirection, eyeDirection), 0.0);
    float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
	vec3 night = nightStep * (0.3 - diffuseLightWeighting) * nightImageColor.rgb;	
	night *= overGround * step(0.0, night);



	vec3 spec = specularMaterial[0].rgb * pow( reflection, specularMaterial[0].w) * shininess;
    vec3 lightWeighting = ambientMaterial[0] + diffuseMaterial[0] * diffuseLightWeighting + spec;	

	vec4 t = texture2D( defaultTexture, vTextureCoord.xy );
	gl_FragData[0] = vec4(t.rgb * lightWeighting + night + spec, t.a);
	gl_FragData[1] = vec4(0.0);
	gl_FragData[2] = vec4(range24, gl_FragData[0].a);
	if( samplerCount == 0 ) return;



	spec = specularMaterial[1].rgb * pow( reflection, specularMaterial[1].w);
    lightWeighting = ambientMaterial[1] + diffuseMaterial[1] * diffuseLightWeighting + spec;	

	t = texture2D( samplerArr[0], tileOffsetArr[0].xy + vTextureCoord.xy * tileOffsetArr[0].zw ) * insideBox(visibleExtentOffsetArr[0].xy + vTextureCoord.xy * visibleExtentOffsetArr[0].zw, BOTTOMLEFT, TOPRIGHT);
	float emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[0].rgb ));
	gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, t.a), transparentColorArr[0].a * emptiness);
	emptiness = step(1.0, emptiness);
	gl_FragData[1] = vec4(pickingColorArr[0], emptiness);
	gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);
	if( samplerCount == 1 ) return;



	spec = specularMaterial[2].rgb * pow( reflection, specularMaterial[2].w);
    lightWeighting = ambientMaterial[2] + diffuseMaterial[2] * diffuseLightWeighting + spec;	

	t = texture2D( samplerArr[1], tileOffsetArr[1].xy + vTextureCoord.xy * tileOffsetArr[1].zw ) * insideBox(visibleExtentOffsetArr[1].xy + vTextureCoord.xy * visibleExtentOffsetArr[1].zw, BOTTOMLEFT, TOPRIGHT);
	emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[1].rgb ));
	gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, t.a), transparentColorArr[1].a * emptiness);
	emptiness = step(1.0, emptiness);
	gl_FragData[1] = mix( gl_FragData[1], vec4(pickingColorArr[1], 1.0), emptiness);
	gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);
	if( samplerCount == 2 ) return;



	spec = specularMaterial[3].rgb * pow( reflection, specularMaterial[3].w);
    lightWeighting = ambientMaterial[3] + diffuseMaterial[3] * diffuseLightWeighting + spec;	

	t = texture2D( samplerArr[2], tileOffsetArr[2].xy + vTextureCoord.xy * tileOffsetArr[2].zw ) * insideBox(visibleExtentOffsetArr[2].xy + vTextureCoord.xy * visibleExtentOffsetArr[2].zw, BOTTOMLEFT, TOPRIGHT);
	emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[2].rgb ));
	gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, t.a), transparentColorArr[2].a * emptiness);
	emptiness = step(1.0, emptiness);
	gl_FragData[1] = mix( gl_FragData[1], vec4(pickingColorArr[2], 1.0), emptiness);
	gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);
	if( samplerCount == 3 ) return;



	spec = specularMaterial[4].rgb * pow( reflection, specularMaterial[4].w);
    lightWeighting = ambientMaterial[4] + diffuseMaterial[4] * diffuseLightWeighting + spec;	

	t = texture2D( samplerArr[3], tileOffsetArr[3].xy + vTextureCoord.xy * tileOffsetArr[3].zw ) * insideBox(visibleExtentOffsetArr[3].xy + vTextureCoord.xy * visibleExtentOffsetArr[3].zw, BOTTOMLEFT, TOPRIGHT);
	emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[3].rgb ));
	gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, t.a), transparentColorArr[3].a * emptiness);
	emptiness = step(1.0, emptiness);
	gl_FragData[1] = mix( gl_FragData[1], vec4(pickingColorArr[3], 1.0), emptiness);
	gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);
	if( samplerCount == 4 ) return;



	spec = specularMaterial[5].rgb * pow( reflection, specularMaterial[5].w);
    lightWeighting = ambientMaterial[5] + diffuseMaterial[5] * diffuseLightWeighting + spec;	

	t = texture2D( samplerArr[4], tileOffsetArr[4].xy + vTextureCoord.xy * tileOffsetArr[4].zw ) * insideBox(visibleExtentOffsetArr[4].xy + vTextureCoord.xy * visibleExtentOffsetArr[4].zw, BOTTOMLEFT, TOPRIGHT);
	emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[4].rgb ));
	gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, t.a), transparentColorArr[4].a * emptiness);
	emptiness = step(1.0, emptiness);
	gl_FragData[1] = mix( gl_FragData[1], vec4(pickingColorArr[4], 1.0), emptiness);
	gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);
}