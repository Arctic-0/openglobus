precision highp float;

#define MAX_POINT_LIGHTS 1

uniform vec3 lightsPositions[MAX_POINT_LIGHTS];
uniform vec3 lightsParamsv[MAX_POINT_LIGHTS * 3];
uniform float lightsParamsf[MAX_POINT_LIGHTS];

#define MAX_TEX 4

uniform int numTex;
uniform sampler2D uSamplerArr[MAX_TEX];
uniform vec4 tcolorArr[MAX_TEX];
uniform lowp vec3 texBiasArr[MAX_TEX];
uniform sampler2D uNormalMap;
//uniform sampler2D uGeoImage;
uniform sampler2D uNightImage;
uniform sampler2D uSpecularImage;

varying vec4 vTextureCoord;
varying vec3 vNormal;
varying vec4 vPosition;
varying mat3 v_NMatrix;
//varying vec2 vTextureCoordClear;
varying vec2 vGlobalTextureCoord;

void main(void)
{
    vec4 nm = texture2D(uNormalMap, vTextureCoord.zw);
    vec3 normal = normalize(v_NMatrix * ((nm.xyz - 0.5) * 2.0));

    vec3 lightDirection = normalize(lightsPositions[0] - vPosition.xyz);
    //float distance = length(dir);
    //float attenuation = 1.0/(1.0+0.1*distance+0.01*distance*distance);
    vec3 eyeDirection = normalize(-vPosition.xyz);
    vec3 reflectionDirection = reflect(-lightDirection, normal);    

	vec4 nightImageColor = texture2D( uNightImage, vGlobalTextureCoord.st );
	float shininess = texture2D( uSpecularImage, vGlobalTextureCoord.st ).r * 255.0;
    float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), lightsParamsf[0]);
    float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);

	vec3 spec = lightsParamsv[2] * specularLightWeighting * shininess;
    vec3 lightWeighting = lightsParamsv[0] + lightsParamsv[1] * diffuseLightWeighting + spec;

	vec3 night = 10.0 * vec3(0.58, 0.48, 0.25) * (0.3 - diffuseLightWeighting) * nightImageColor.rgb;	

    lowp vec4 res = texture2D(uSamplerArr[0], texBiasArr[0].z * (vTextureCoord.xy + vec2(texBiasArr[0].x, texBiasArr[0].y)));

        for( int i = 1; i < MAX_TEX; i++ ) 
        {
            if( i < numTex) 
            {
                vec4 ti = texture2D(uSamplerArr[i], texBiasArr[i].z * (vTextureCoord.xy + texBiasArr[i].xy));
                res = mix(res, ti, tcolorArr[i].w * ti.a * smoothstep(0.35, 0.5, distance( ti.rgb, tcolorArr[i].xyz )));
            }
            else
            {
                break;
            }
        }

	//vec4 geoImageColor = texture2D( uGeoImage, vTextureCoordClear.st );
    gl_FragColor = res/*mix(res, geoImageColor, geoImageColor.a)*/ * vec4(lightWeighting, 1.0) + vec4(night * step(0.0, night) + spec, 1.0);
}