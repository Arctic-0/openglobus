precision highp float;

uniform sampler2D uSampler;
uniform sampler2D uNormalMap;

#define MAX_POINT_LIGHTS 1

uniform vec3 pointLightsPositions[MAX_POINT_LIGHTS];
uniform vec3 pointLightsParamsv[MAX_POINT_LIGHTS * 3];
uniform float pointLightsParamsf[MAX_POINT_LIGHTS];
uniform mat3 uNMatrix;
uniform sampler2D uGeoImage;

varying vec4 vTextureCoord;
varying vec4 vPosition;
varying mat3 v_NMatrix;
varying vec2 vTextureCoordClear;

void main(void) {
    
    vec4 nm = texture2D(uNormalMap, vTextureCoord.zw);
    vec3 normal = normalize(uNMatrix * ((nm.xyz - 0.5) * 2.0));

    vec3 lightDirection = normalize(pointLightsPositions[0] - vPosition.xyz);
    //float distance = length(dir);
    //float attenuation = 1.0/(1.0+0.1*distance+0.01*distance*distance);
    vec3 eyeDirection = normalize(-vPosition.xyz);
    vec3 reflectionDirection = reflect(-lightDirection, normal);
    
    float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), pointLightsParamsf[0]);
    float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
    vec3 lightWeighting = pointLightsParamsv[0] + pointLightsParamsv[1] * diffuseLightWeighting + pointLightsParamsv[2] * specularLightWeighting;

    vec4 uColor = texture2D( uSampler, vTextureCoord.xy );
    vec4 geoImageColor = texture2D( uGeoImage, vTextureCoordClear.st );
    vec4 res = mix(uColor, geoImageColor, geoImageColor.a);

    //gl_FragColor = vec4(uColor.rgb * lightWeighting, uColor.a);
	gl_FragColor = vec4(res.rgb * lightWeighting, res.a);
}