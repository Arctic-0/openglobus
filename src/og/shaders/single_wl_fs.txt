precision highp float;

uniform sampler2D uSampler;
uniform sampler2D uNormalMap;

#define MAX_POINT_LIGHTS 1

uniform vec3 pointLightsPositions[MAX_POINT_LIGHTS];
uniform vec3 pointLightsParamsv[MAX_POINT_LIGHTS * 3];
uniform float pointLightsParamsf[MAX_POINT_LIGHTS];
uniform mat3 uNMatrix;
uniform sampler2D uGeoImage;
uniform sampler2D uNightImage;

varying vec4 vTextureCoord;
varying vec4 vPosition;
varying mat3 v_NMatrix;
varying vec2 vTextureCoordGeoImage;
varying vec2 vGlobalTextureCoord;

void main(void) {
    
    vec3 normal = normalize(uNMatrix * ((texture2D(uNormalMap, vTextureCoord.zw).rgb - 0.5) * 2.0));

    vec3 lightDirection = normalize(pointLightsPositions[0] - vPosition.xyz);
    //float distance = length(dir);
    //float attenuation = 1.0/(1.0+0.1*distance+0.01*distance*distance);
    vec3 eyeDirection = normalize(-vPosition.xyz);
    vec3 reflectionDirection = reflect(-lightDirection, normal);
    
    float specularLightWeighting = pow( max( dot(reflectionDirection, eyeDirection), 0.0), pointLightsParamsf[0]);
    float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
    vec3 lightWeighting = pointLightsParamsv[0] + pointLightsParamsv[1] * diffuseLightWeighting + pointLightsParamsv[2] * specularLightWeighting;

    vec4 uColor = texture2D( uSampler, vTextureCoord.xy );
    vec4 geoImageColor = texture2D( uGeoImage, vTextureCoordGeoImage.st );
    vec4 nightImageColor = texture2D( uNightImage, vGlobalTextureCoord.st );

	vec3 night = nightImageColor.rgb * (1.0 - lightWeighting);
	
    vec4 res = mix(uColor, geoImageColor, geoImageColor.a);

	gl_FragColor = vec4(res.rgb * lightWeighting + night * step(0.0, night), res.a);
}