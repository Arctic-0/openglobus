precision highp float;

uniform sampler2D uSampler;
uniform sampler2D uNormalMap;

#define MAX_POINT_LIGHTS 1

uniform vec3 pointLightsPositions[MAX_POINT_LIGHTS];
uniform vec3 pointLightsParamsv[MAX_POINT_LIGHTS * 3];
uniform float pointLightsParamsf[MAX_POINT_LIGHTS];
uniform mat3 uNMatrix;
uniform sampler2D uGeoImage;
uniform sampler2D uNightImage;
uniform sampler2D uSpecularImage;

varying vec4 vTextureCoord;
varying vec4 vPosition;
varying mat3 v_NMatrix;
varying vec2 vTextureCoordGeoImage;
varying vec2 vGlobalTextureCoord;

void main(void) {
    
    vec3 normal = normalize(uNMatrix * ((texture2D(uNormalMap, vTextureCoord.zw).rgb - 0.5) * 2.0));

    vec3 lightDirection = normalize(pointLightsPositions[0] - vPosition.xyz);
    //float distance = length(dir);
    //float attenuation = 1.0/(1.0+0.1*distance+0.01*distance*distance);
    vec3 eyeDirection = normalize(-vPosition.xyz);
    vec3 reflectionDirection = reflect(-lightDirection, normal);
    
	vec4 uColor = texture2D( uSampler, vTextureCoord.xy );
    vec4 geoImageColor = texture2D( uGeoImage, vTextureCoordGeoImage.st );
    vec4 nightImageColor = texture2D( uNightImage, vGlobalTextureCoord.st );

    float shininess = texture2D( uSpecularImage, vGlobalTextureCoord.st ).r * 255.0;

    float specularLightWeighting = pow( max( dot(reflectionDirection, eyeDirection), 0.0), pointLightsParamsf[0]);
    float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
	vec3 spec = pointLightsParamsv[2] * specularLightWeighting * shininess;
    vec3 lightWeighting = pointLightsParamsv[0] + pointLightsParamsv[1] * diffuseLightWeighting + spec;
	
	vec3 night = 10.0 * vec3(0.58, 0.48, 0.25) * (0.3 - diffuseLightWeighting) * nightImageColor.rgb;	

    vec4 res = mix(uColor, geoImageColor, geoImageColor.a);

	gl_FragColor = vec4(res.rgb * lightWeighting + night * step(0.0, night) + spec, res.a);
}